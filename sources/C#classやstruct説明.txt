struct 型は、Point、Rectangle、Color などの軽量のオブジェクトを表すのに適しています。点はクラスで表現できますが、一部の事例では構造体の方がより効果的です。たとえば、1,000 個の Point オブジェクトから成る配列を宣言する場合は、各オブジェクトの参照用に新たにメモリが割り当てられます。この場合は、構造体を使用した方がリソースを使用しません。

構造体に対して既定の (パラメータなしの) コンストラクタを宣言するとエラーになります。構造体メンバを既定値に初期化する既定のコンストラクタが常備されています。

構造体のインスタンス フィールドを初期化するとエラーになります。

new 演算子を使用して struct オブジェクトを作成すると、オブジェクトが作成されて適切なコンストラクタが呼び出されます。クラスとは異なり、構造体は new 演算子を使用せずにインスタンスを作成できます。new を使用しなかった場合、各フィールドは未割り当てのままになり、すべてのフィールドが初期化されるまでオブジェクトを使用できません。

クラスには継承がありますが、構造体には継承がありません。構造体は、他の構造体やクラスから継承できず、基本クラスになれません。ただし、構造体は、基本クラス Object から継承します。構造体は、クラスの場合とまったく同じ方法でインターフェイスを実装できます。

C++ とは異なり、キーワード struct を使用してクラスを宣言できません。C# では、クラスと構造体は、意味が異なります。構造体は値型ですが、クラスは参照型です。値型の機能の詳細については、「値型」を参照してください。

参照型の機能が必要な場合以外は、16 バイト未満のクラスの方が、構造体としてより効果的に処理されることがあります。

構造体の詳細については、「11. 構造体」および「構造体のチュートリアル」を参照してください。

C++ マネージ拡張で C# のクラスおよび構造体に相当するものは、次のとおりです。
=====================================================================================
構造体はクラスに似ていて、データ メンバおよび関数メンバを格納できるデータ構造を表します。クラスと異なるのは、構造体は値型であり、ヒープ割り当てを必要としません。構造体型の変数は構造体のデータを直接格納します。クラス型の変数はデータへの参照を格納します。後者はオブジェクトと呼ばれます。

構造体は、値セマンティクスを持つ小規模なデータ構造に特に役立ちます。構造体に適した例としては、複雑な数値、座標システム内の点、またはディクショナリ内のキー値のペアがあります。これらのデータ構造にとって重要な点は、データ メンバが少ないこと、継承や参照 ID を使う必要がないこと、および代入により参照ではなく、値をコピーする値セマンティクス使って、手軽に実装できることです。

「4.1.3 単純型」で説明されているように、int、double、bool など、C# によって提供される単純な型は実際はすべて構造体型です。これらの定義済みの型が構造体であるのと同様に、構造体と演算子のオーバーロードを使って、C# 言語の "プリミティブ" な新規の型を実装できます。型についての 2 つの例をこの章の最後に示します (11.4 を参照)。
=====================================================================================
インターフェイスはコントラクトを定義します。インターフェイスを実装するクラスや構造体は、そのコントラクトと一致する必要があります。インターフェイスは複数の基本インターフェイスから継承できます。また、クラスや構造体は複数のインターフェイスを実装できます。

インターフェイスには、メソッド、プロパティ、イベント、およびインデクサを含めることができます。インターフェイス自体は、インターフェイスが定義するメンバの実装を提供しません。インターフェイスは、そのインターフェイスを実装するクラスまたは構造体が提供するメンバを指定するだけです。


C++:__gc class  -->  C#:class 参照型
C++:__value class  --> C#:struct 値型
C#delegate ==関数参照
C#enum 列挙型(定数群)
C#interface インターフェイス

