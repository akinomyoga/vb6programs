


------------------------------------------------------------------------------
  VB6 Note
------------------------------------------------------------------------------

UserControl を自分で作るという事。

* 描画処理は UserControl_Paint にかけば良い。
  表示内容の変化があったら UserControl.Refresh() を呼び出す。

* デザイナの UserControl のプロパティがそのまま
  作成しているコントロールのプロパティになるのかと思っていたら違う様だ。
  作成しているコントロールの中に UserControl がある様である。
  従って、プロパティを自分で定義して中の UserControl に橋渡しする必要がある。

  Ref: [[RESOLVED] Custom control - Font and color properties-VBForums](http://www.vbforums.com/showthread.php?463202-RESOLVED-Custom-control-Font-and-color-properties)

* UserControl にプロパティを追加する方法は以下に書かれていた。

  Ref: [properties - Add property to user control in vb6 - Stack Overflow](https://stackoverflow.com/questions/41087947/add-property-to-user-control-in-vb6)

* プロパティを作成する為には以下のような感じにする。

  * 値型のプロパティの場合

    Dim m_Value As Boolean

    Public Property Let Value(ByVal new_Value As Boolean)
        m_Value = new_Value
        PropertyChanged "Value"
    End Property

    Public Property Get Value() As Boolean
        Value = m_Value
    End Property

  * 参照型のプロパティの場合

    参照型と値型でプロパティの作成の仕方が異なる様だ。
    フォントのプロパティ等参照型の場合には以下の様にする。

    Public Property Set Font(ByRef new_Font As StdFont)
        Set UserControl.Font = new_Font
        PropertyChanged "Font"
    End Property

    Public Property Get Font() As StdFont
        Set Font = UserControl.Font
    End Property

    初め値型と同じ様にフォントのプロパティを作成してみたら、
    Wrong number of argauments or invalid property と言った具合のエラーメッセージが出た。

    Ref: [[RESOLVED] User Control Picture Error Problem-VBForums](http://www.vbforums.com/showthread.php?744107-RESOLVED-User-Control-Picture-Error-Problem)

  * 更にデザイナでユーザの設定したプロパティが正しく保存される為に以下の様に記述する。

    Private Sub UserControl_InitProperties()
        m_Value = default_Value
        Set default_Font = UserControl.Font
    End Sub

    Private Sub UserControl_ReadProperties(PropBag As PropertyBag)
        m_Value = PropBag.ReadProperty("Value", default_Value)
        Set UserControl.Font = PropBag.ReadProperty("Font", getDefaultFont())
    End Sub

    Private Sub UserControl_WriteProperties(PropBag As PropertyBag)
        Call PropBag.WriteProperty("Value", m_Value, default_Value)
        Call PropBag.WriteProperty("Font", UserControl.Font, getDefaultFont())
    End Sub


------------------------------------------------------------------------------
  ToDo
------------------------------------------------------------------------------



------------------------------------------------------------------------------
  Done
------------------------------------------------------------------------------

2019-07-12

* KBasic: ScrollBar のアイコン

* KBasic: SpinButton と ScrollBar の Timer にも対応した。
  これで一応 ScrollBar は実装できたのではないだろうか。

* KBasic: 何と VB6 の Integer は 16bit 整数の様だ。
  32bit 整数は Long を使う必要がある。
  後で全体的に Integer から Long に書き換える必要がある。

2019-07-10

* KBasic: プロパティを設定する前に前と同じ値になっていないかどうか確認する [#D0007]

* KBasic: SpinButton の Enabled に対応する [#D0006]

* KBasic: ToggleButton の Enabled に対応する [#D0005]

* KBasic: ToggleButton を押している時は Inset にする? [#D0004]

* KBasic: MouseCapture? [#D0003]

  * 対応しようとしたら double click の後に
    領域外に移動してからボタンを離すとボタンが離れたことを検知できない。

    | 検索して調べてみるが使えそうな物はない。
    | Win API を呼び出して色々しなければならないのだろうか。
    | 調べてみると ControlStyles.StandardDoubleClick という物があるそう。
    | https://docs.microsoft.com/ja-jp/dotnet/api/system.windows.forms.controlstyles?view=netframework-4.8
    | http://wisdom.sakura.ne.jp/system/msnet/msnet_win24.html
    | 
    | これは CreateWindow の Window Style に対応していそう。
    | StandardDoubleClick は 4096 の様である。
    | https://www.vb-helper.com/howto_change_window_style.html によると
    | Window Style の設定には Win32 API を呼び出している。
    | http://hanatyan.sakura.ne.jp/vb6/commandbutton03.htm でもそうしている。
    | 
    | うーん。拡張スタイルもスタイルも見てみたが Double Click に関係ありそうな物はない。
    | https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-setwindowlongptra
    | https://docs.microsoft.com/ja-jp/windows/win32/winmsg/window-styles
    | https://docs.microsoft.com/ja-jp/windows/win32/winmsg/extended-window-styles
    | うーん。試しに設定してみたが変化はない。
    | 
    |   % Const GWL_STYLE = -16
    |   % Const GWL_EXSTYLE = -20
    |   % 
    |   % Private Declare Function GetWindowLong Lib "user32" _
    |   %     Alias "GetWindowLongA" (ByVal hwnd As Long, _
    |   %     ByVal nIndex As Long) As Long
    |   % 
    |   % Private Declare Function SetWindowLong Lib "user32" _
    |   %     Alias "SetWindowLongA" (ByVal hwnd As Long, _
    |   %     ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
    |   % 
    |   % 
    |   % Dim style As Long
    |   % style = GetWindowLong(hwnd, GWL_STYLE)
    |   % style = style And Not 4096
    |   % Call SetWindowLong(UserControl.hwnd, GWL_EXSTYLE, style)
    | 
    | http://cya.sakura.ne.jp/vb/MSHFlexGrid_Event.htm
    | ここによると気になる事が書かれている。Click を処理すると DblClick が呼び出されなく為る。
    | しかしこれはグリッドコントロール特有の振る舞いではないだろうか。
    | 
    | http://suvaru.com/pg/sampl/Sample100_20.html
    | ここによると「Visual BasicはMouseDownごとにSetCapture APIを呼び出すが、」と書かれている。
    | つまり、DblClick で SetCapture を呼び出してしまえば良い?
    | →結局これで動く様になった。

    [解決法] Win32 API を呼び出す。
      UserControl_DblClick で SetCapture UserControl.hWnd を呼び出し、
      UserControl_MouseUp で ReleaseCapture を呼び出す。

* KBasic: ColorBox の Enabled に対応する [#D0002]
  Enabled に対応しようとしたら無限ループになってしまって全然駄目だ。
  どうも UserControl.Refresh を実行すると Enabled が有効化される?
  しかし UserControl.Refresh を実行しないと表示は更新されない。
  誰かが Enabled に True を設定しているのだろうか。。。

  新しく作成した TestControl で Property Enabled だけ追加してみたが問題は起こらない。
  つまり、ColorButton のコードの方で何か変な事をしている。
  調べたら ForeColor 設定 → Refresh → ForeColor 設定というループになっていた。
  修正した。

2019-07-09

* KBasic: VB6 の UserControl の ToolBoxBitmap の大きさが分からない。 [#D0001]
  21x21 が最大サイズの様であるが 21x21 のファイルを指定するとぼやけてしまう。
  12x12 でもぼやけてしまう。というか黒が白に変換されている?
  16x16 だと下偏が欠けてしまっている。
  因みに昔自分が作った UserControl に設定されている Bitmap は 14x13 の様に見える。

  * 25x25 にしてみたら内容が潰れてしまう。
    13px が 7px に縮小されている。
    変更前 25 23 21 19 17 15 (25x25 BMP 内の大きさ)
    変更後 15 13 13 11 11 7  (実際に表示される大きさ)
    うーん。描画位置にもよるので一概には言えない気がする。
    取り敢えず 15x15 が標準の大きさ?

  * 15x15 にして見たら右端が欠けるという事態になった。
    これは透明色を周囲の色で一番多い物としている為であろう。
    15x15 にして端を黄緑にしてみたらよくなった。
    ハッチ模様も壊れていない。しかし15x16になってしまっている。
    うーん。15x16でやってみたらうまく行った。

  [結論] 15x16 が標準の大きさで周囲で、一番多い色が透明色になる
